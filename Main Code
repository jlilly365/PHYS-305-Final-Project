#include <stdio.h>
#include <math.h>

float RHS(int ieq, float R, float M, float P, float D)
{
 float dM = 0.0; //differential mass
 float dP = 0.0; //differential pressure

 float gamma = 4.0 / 3.0; //exponent number for p = dens ^ gamma
=======
 
//ieq = 0 is mass
  if(ieq == 0)
  {
   dM = D * pow(R,3);
   // printf("dM: %e\n", dM);
   dM = pow(R,2) * D;
   return dM;   
  }

 //ieq = 1 is pressure
 else if(ieq == 1)
 {
   dP = (M / (2.0 * pow(R,2))) * (1.0 + (P / D)) * (1.0 + (pow(R,3) * P) / M) * (1.0 - (M / R));
   return dP;
 }
 
 //ieq = 2 is density
  else if(ieq == 2)
  {
    D = pow(P,(1.0 / gamma));
    return D;
  }
 
 //in case ieq is the wrong value
  else
  {
    printf("Error. :(\n");
    return 0;
  }
}

int main(void)
{
 //what are our initial values??
  float k1[3] = {0.0, 1.0, 1.0}; //mass, degen. pressure (outward), density
  float k2[3] = {0.0, 0.0, 0.0}; //mid values for everything above
  float k3[3] = {0.0, 0.0, 0.0}; //more mid vals
  float k4[3] = {0.0, 0.0, 0.0}; //more mid vals
  float R = 0.0;                 //radius
  float steps = 128;	         //number of step
  float h = 1.0 / (float)steps;  //actual step amount
  int i = 0; 	   	         //radius loop counter
  int j = 0;                     //equation loop counter
  int k = 0;                     //error loop counter
  int l, m, n;                   //individual k counters
  
  //radius goes from almost 0 to well beyond what should be the minimum radius in km  
  for(i = 1; i <= steps ; i++) 
    {	     
      R = 1.0 * (float)i;

      //printf("%e\n", R);
 
      //to calculate mass and degen pressure for each half step
      //xmid1 = x + step/2 * dx
      for(j = 0; j < 3; j++)
	{    
	  k2[j] = k1[j] + (h / 2.0) * RHS(j,R,k1[0],k1[1],k1[2]);
	  printf("mass: %e\n", k2[0]);
	}

      //xmid2 = x + step/2 * dx
      for(l = 0; l < 3; l++)
	{ 
	  k3[l] = k2[l] + (h / 2.0) * RHS(l,R,k2[0],k2[1],k2[2]);
	}

      //xmid3 = x + step/2 * dx
      for(m = 0; m < 3; m++)
	{
	  k4[m] = k3[m] + (h / 2.0) * RHS(m,R,k3[0],k3[1],k3[2]);
	}

      //x = x + step * dxmid3
      for(n = 0; n < 3; n++)
	{
	  k1[n] = k1[n] + h * RHS(n,R,k4[0],k4[1],k4[2]);
	}
     printf("%e %e\n", k1[1], k1[2]);
    }

 

  return 0;
}


//////////////////////////////////////////////////////////////////////
//* RK METHOD FOR ORBITS FROM CLASS
/*
float RHS(int ieq, float x, float y, float ux, float uy)
{
  float dux = 0.0;
  float duy = 0.0;

  if(ieq == 0) //x
    {
      return ux;
    }
  else if(ieq == 1) //y
    {
      return uy;
    }
  else if(ieq == 2) //ux
    {
      dux = -x / (pow(x*x + y*y, 3.0/2.0) + pow(10,-6));
      return dux;
    }
  else if(ieq == 3) //uy
    {
      duy = -y / (pow(x*x + y*y, 3.0/2.0) + pow(10,-6));
      return duy;
    }
  else
    {
      printf("Error\n");
      return 0.0;
    }

}

int main(void)
{

  float t = 0.0;
  float var[4] = {1.0, 0.0, 0.0, 1.0};    //x, y, ux, uy
  float midvar[4] = {0.0, 0.0, 0.0, 0.0}; //xmid, ymid, uxmid, uymid
  float h = 2048.0;
  float step = 1.0 / h;
  int i = 0;
  float j = 0.0;
  float E = 0.0;
  float E0 = -0.5;
  float error = 0.0;

for(j = 1.0; j <= pow(2,20); j = j * 2.0)
    {     
      //printf("Loop #%d\n", j);   
      h = j;   
      step = 1.0 / h;
      
      //reinitialize initial conditions
      var[0] = 1.0;
      var[1] = 0.0;
      var[2] = 0.0;
      var[3] = 1.0;
     
      for(t = 0.0;t <= 10.0; t = t + step)
	{	
	  //printf("%e\t%e\n", var[0], var[1]);     
	  for(i = 0; i < 4; i++) 
	    {    
	      //xmid = x + step/2 * dx	 
	      midvar[i] = var[i] + (step / 2.0) * RHS(i,var[0],var[1],var[2],var[3]);
	 
	      //x = x + step * dxmid
	      var[i] = var[i] + step * RHS(i,midvar[0],midvar[1],midvar[2],midvar[3]);
	    }
	}
     
      E = 0.5 * (pow(var[2],2) + pow(var[3],2)) - pow(pow(var[0],2) + pow(var[1],2), -0.5);

      error = fabs((E - E0) / E0);
      printf("%e %e\n", step, error);
    }
      

  return 0;
}

*/
