#include <stdio.h>
#include <math.h>

float RHS(int ieq, float R, float M, float D, float P)
{
 float R0 = 0.0; //value for R0
 float dM = 0.0; //differential mass
 float dD = 0.0; //differential density
 float dP = 0.0; //differential pressure

 // finish this R0 = pow(
 
//ieq = 0 is mass
  if(ieq == 0)
  {
   dM = R0 * D * pow(R,3);
   return dM;   
  }

//ieq = 1 is density
  else if(ieq == 1)
  {
    //insert diff eq here
    return dD;
  }
 
 //ieq = 2 is pressure
 else if(ieq == 2)
 {
  dP = (M / (2 * pow(R,2)) * (1 + (P / D)) * (1 + (pow(R,3) * P / M)) * (1 - (M / R));
    return dP;
 }
 
 //in case ieq is the wrong value
  else
  {
    printf("Error. :(\n");
    return 0;
  }
}

int main(void)
{
 //what are our initial values??
  float k1[3] = {0.0, 0.0, 0.0}; //mass, density, degen. pressure (outward)
  float k2[3] = {0.0, 0.0, 0.0}; //mid values for everything above
  float R = 0.0;	//radius
  float h = 8.0;	//step precision
  float step = 1.0/h;	//actual step
  int i = 0; 	   	//equation loop counter
  
  for(R = 0.00001; R <= 20.0; R = R + step) //radius goes from almost 0 to well beyond what should be the minimum radius in km
	{	     
	  for(i = 0; i < 3; i++) //to calc mass, density, degen press
	    {    
	      //xmid = x + step/2 * dx	 
	      k2[i] = k1[i] + (step / 2.0) * RHS(i,R,k1[0],k1[1],k1[2]);
	 
	      //x = x + step * dxmid
	      k1[i] = k1[i] + step * RHS(i,R,k2[0],k2[1],k2[2]);
	    }
	}

  return 0;
}

//////////////////////////////////////////////////////////////////////
//* RK METHOD FOR ORBITS FROM CLASS
/*
float RHS(int ieq, float x, float y, float ux, float uy)
{
  float dux = 0.0;
  float duy = 0.0;

  if(ieq == 0) //x
    {
      return ux;
    }
  else if(ieq == 1) //y
    {
      return uy;
    }
  else if(ieq == 2) //ux
    {
      dux = -x / (pow(x*x + y*y, 3.0/2.0) + pow(10,-6));
      return dux;
    }
  else if(ieq == 3) //uy
    {
      duy = -y / (pow(x*x + y*y, 3.0/2.0) + pow(10,-6));
      return duy;
    }
  else
    {
      printf("Error\n");
      return 0.0;
    }

}

int main(void)
{

  float t = 0.0;
  float var[4] = {1.0, 0.0, 0.0, 1.0};    //x, y, ux, uy
  float midvar[4] = {0.0, 0.0, 0.0, 0.0}; //xmid, ymid, uxmid, uymid
  float h = 2048.0;
  float step = 1.0 / h;
  int i = 0;
  float j = 0.0;
  float E = 0.0;
  float E0 = -0.5;
  float error = 0.0;

for(j = 1.0; j <= pow(2,20); j = j * 2.0)
    {     
      //printf("Loop #%d\n", j);   
      h = j;   
      step = 1.0 / h;
      
      //reinitialize initial conditions
      var[0] = 1.0;
      var[1] = 0.0;
      var[2] = 0.0;
      var[3] = 1.0;
     
      for(t = 0.0;t <= 10.0; t = t + step)
	{	
	  //printf("%e\t%e\n", var[0], var[1]);     
	  for(i = 0; i < 4; i++) 
	    {    
	      //xmid = x + step/2 * dx	 
	      midvar[i] = var[i] + (step / 2.0) * RHS(i,var[0],var[1],var[2],var[3]);
	 
	      //x = x + step * dxmid
	      var[i] = var[i] + step * RHS(i,midvar[0],midvar[1],midvar[2],midvar[3]);
	    }
	}
     
      E = 0.5 * (pow(var[2],2) + pow(var[3],2)) - pow(pow(var[0],2) + pow(var[1],2), -0.5);

      error = fabs((E - E0) / E0);
      printf("%e %e\n", step, error);
    }
      

  return 0;
}

*/
